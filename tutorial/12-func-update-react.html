<!DOCTYPE html><html>
<head>
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="stylesheet" href="normalize.css">
<link rel="stylesheet" href="skeleton.css">
<link rel="stylesheet" href="prism.css">
<link rel="stylesheet" href="style.css">
</head>
<body class="container">
<script src="https://flems.io/flems.html" type="text/javascript" charset="utf-8"></script>
<script src="prism.js" type="text/javascript"></script>
<h1>Meiosis Tutorial</h1><p><a href="toc.html">Table of Contents</a></p>
<h2>12 - Function Update</h2><p>In the previous lesson, <a href="11-components-react.html">11 - Components</a>, we organized code into
components in the form of plain <code>{ model: ..., view: ... }</code> objects. We augmented our <code>nest</code>
function to conveniently wrap the <code>model</code> and <code>view</code> functions with a nested property. That way,
we could construct the top-level model from each component&#39;s <code>model()</code>, and we could call each
component&#39;s <code>view(model)</code> function without worrying about which submodel to pass to which
component.</p>
<p>At this point, we&#39;ve been issuing updates in the form of objects and producing the updated model
with a deep merge function. This is a fine approach; feel free to use it if it works well for
you. However, also know that there are other ways to issue updates and update the model. It&#39;s
your choice - the essence of the Meiosis pattern is the simple reactive loop: rendering
<code>view(model)</code>, issuing updates, producing an updated model, and re-rendering the view.</p>
<p>Now, let&#39;s look at another way to issue updates: with <strong>functions</strong>.</p>
<h3>Passing functions to <code>update()</code></h3><p>In the Meiosis pattern setup code, we use <code>scan</code> with an accumulator function and a stream of
updates. The accumulator function receives the latest model, and what was passed to <code>update()</code>.
Previously, those updates were plain objects, and we merged them into the model:</p>
<pre><code class="language-js">function(model, object) {
  return _.merge(model, object);
}
</code></pre>
<p>Or simply <code>_.merge</code>.</p>
<p>Now, we&#39;ll change our strategy. We&#39;ll pass <strong>functions</strong> to <code>update()</code>. This is what&#39;s used in
the majority of the Meiosis examples, because it gives you a lot of flexibility.</p>
<p>Remember that functions are values that we can pass to other functions and return from other
functions. The functions that we&#39;ll pass to <code>update()</code> are functions that receive the latest
model and return the updated model.</p>
<p>For example, previously to set the temperature value to 23, we&#39;d write:</p>
<pre><code class="language-js">update({ value: 23 });
</code></pre>
<p>Now, we&#39;ll write:</p>
<pre><code class="language-js">update(function(model) {
  model.value = 23;
  return model;
});
</code></pre>
<p>This makes our updates a stream of functions that update the model. Our accumulator function
becomes:</p>
<pre><code class="language-js">function(model, func) {
  return func(model);
}
</code></pre>
<p>That is, given the latest model and the incoming function <code>func</code> from the <code>update</code> stream,
producing the updated model is simply done by calling <code>func(model)</code>.</p>
<p>The <code>scan</code> in our Meiosis setup code becomes:</p>
<pre><code class="language-js">var models = flyd.scan(function(model, func) {
  return func(model);
}, app.model(), update);
</code></pre>
<p>Take a minute to let that sink in.</p>
<h3>Nesting Updates</h3><p>For nesting, the handling of our <code>model</code> and <code>view</code> functions remains the same. But what about
nesting updates? Previously, we had:</p>
<pre><code class="language-js">var nestUpdate = function(update, prop) {
  return function(obj) {
    var result = {};
    result[prop] = obj;
    update(result);
  };
};
</code></pre>
<p>So when we called <code>update({ data... })</code>, <code>nestUpdate</code> would turn that into
<code>update({ prop: { data... }})</code>.</p>
<p><img src="12-func-update-01.svg" alt="Nesting Objects"></p>
<p>Now, we&#39;re calling <code>update(func)</code>, where <code>func</code> gets the <code>model</code> and returns the updated model.
If we&#39;re nesting that at a property, we want to wrap <code>func</code> with a new function that gets the
<strong>unnested</strong> model and passes the <strong>nested model</strong> to <code>func</code>. Then, we assign the result of
calling <code>func</code> to the nested property of the model:</p>
<p><img src="12-func-update-02.svg" alt="Nesting Functions"></p>
<pre><code class="language-js">var nestUpdate = function(update, prop) {
  return function(func) { // this is the nested update. take the incoming func, and
    update(function(model) { // call the original update, and
      model[prop] = func(model[prop]); // call func on the nested model
      return model;
    });
  };
};
</code></pre>
<p>Now that we have <code>nestUpdate</code> ready, let&#39;s see how we issue updates.</p>
<h3>Issuing Updates</h3><p>To issue updates, we call <code>update()</code> and pass it a function. That function receives the latest
model and returns the updated model. Here are our <code>increase</code> and <code>changeUnits</code> event handlers:</p>
<pre><code class="language-js">var increase = function(amount) {
  return function(_event) {
    update(function(model) {
      model.value += amount;
      return model;
    });
  };
};
var changeUnits = function(_event) {
  update(function(model) {
    var newUnits = model.units === &quot;C&quot; ? &quot;F&quot; : &quot;C&quot;;
    model.value = convert(model.value, newUnits);
    model.units = newUnits;
    return model;
  });
};
</code></pre>
<p>Notice how we make changes to the model and then return it. It&#39;s fine to mutate the model object
and return it, but you could also use code that returns a new object as the updated model.</p>
<p>Previously, we had to pass the model to the event handler functions so that it could be used to
calculate the updated values. Now, we automatically get the latest model since it is passed to our
function. We can thus simplify the calls that we make to event handlers.</p>
<h3>Simplifying Calls to Event Handlers</h3><p>With the plain object updates, we needed to pass the model to the event handler functions:</p>
<pre><code class="language-html">&lt;button onClick={increase(model, 1)}&gt;Increase&lt;/button&gt;
&lt;button onClick={increase(model,-1)}&gt;Decrease&lt;/button&gt;
&lt;button onClick={changeUnits(model)}&gt;Change Units&lt;/button&gt;
</code></pre>
<p>Now that we receive the model in the function that we pass to <code>update()</code>, we can simplify the
calls to the event handlers. We no longer need to pass the model:</p>
<pre><code class="language-html">&lt;button onClick={increase( 1)}&gt;Increase&lt;/button&gt;
&lt;button onClick={increase(-1)}&gt;Decrease&lt;/button&gt;
&lt;button onClick={changeUnits}&gt;Change Units&lt;/button&gt;
</code></pre>
<p>Passing functions to <code>update()</code> gives us a lot of flexibility. It&#39;s easy to modify the model in
any way that we want, using any logic that we want, and so on, within the function. The function
always gets passed the latest model, can make the necessary changes, and return the updated model.</p>
<h3>Putting it all together</h3><p>Here is the full example:</p>
  <div id="flems1" class="flemscode" style="height:800px"></div>

  <script>
    window.Flems(flems1, {
      files: [{name: "12-func-update.js", content: "/*global ReactDOM, flyd*/\n\n// -- Utility code\n\nvar nestUpdate = function(update, prop) {\n  return function(func) {\n    update(function(model) {\n      model[prop] = func(model[prop]);\n      return model;\n    });\n  };\n};\n\nvar nest = function(create, prop, update) {\n  var component = create(nestUpdate(update, prop));\n  var result = Object.assign({}, component);\n  if (component.model) {\n    result.model = function() {\n      var initialModel = {};\n      initialModel[prop] = component.model();\n      return initialModel;\n    };\n  }\n  if (component.view) {\n    result.view = function(model) {\n      return component.view(model[prop]);\n    };\n  }\n  return result;\n};\n\n// -- Application code\n\nvar convert = function(value, to) {\n  if (to === \"C\") {\n    return Math.round( (value - 32) / 9 * 5 );\n  }\n  else {\n    return Math.round( value * 9 / 5 + 32 );\n  }\n};\n\nvar createTemperature = function(label, init) {\n  return function(update) {\n    var increase = function(amount) {\n      return function(_event) {\n        update(function(model) {\n          model.value += amount;\n          return model;\n        });\n      };\n    };\n    var changeUnits = function(_event) {\n      update(function(model) {\n        var newUnits = model.units === \"C\" ? \"F\" : \"C\";\n        model.value = convert(model.value, newUnits);\n        model.units = newUnits;\n        return model;\n      });\n    };\n\n    var model = function() {\n      return Object.assign({ value: 22, units: \"C\" }, init);\n    };\n\n    var view = function(model) {\n      return (<div>\n        <span>{label} Temperature: {model.value}&deg;{model.units}</span>\n        <div>\n          <button onClick={increase( 1)}>Increase</button>\n          <button onClick={increase(-1)}>Decrease</button>\n        </div>\n        <div>\n          <button onClick={changeUnits}>Change Units</button>\n        </div>\n      </div>);\n    };\n    return { model: model, view: view };\n  };\n};\n\nvar createTemperaturePair = function(update) {\n  var air = nest(createTemperature(\"Air\"), \"air\", update);\n  var water = nest(createTemperature(\"Water\", { value: 84, units: \"F\" }),\n    \"water\", update);\n\n  var model = function() {\n    return Object.assign(air.model(), water.model());\n  };\n\n  var view = function(model) {\n    return (<div>\n      {air.view(model)}\n      {water.view(model)}\n    </div>);\n  };\n  return { model: model, view: view };\n};\n\nvar createApp = function(update) {\n  return nest(createTemperaturePair, \"temperatures\", update);\n};\n\n// -- Meiosis pattern setup code\n\nvar update = flyd.stream();\nvar app = createApp(update);\n\nvar models = flyd.scan(function(model, func) {\n  return func(model);\n}, app.model(), update);\n\nvar element = document.getElementById(\"app\");\n\nmodels.map(function(model) {\n  ReactDOM.render(app.view(model), element);\n});\n", compiler: "babel"},{name: "app.html", content: "<div id=\"app\"></div>\n"}],
      links: [{name: "react", type: "js", url: "https://unpkg.com/react@16.3.1/umd/react.development.js"},{name: "react-dom", type: "js", url: "https://unpkg.com/react-dom@16.3.1/umd/react-dom.development.js"},{name: "flyd", type: "js", url: "https://unpkg.com/flyd@0.2.6/flyd.js"}],
      middle: 75
    })
  </script>


<h3>Exercise</h3><ul>
<li>Add another component next to <code>temperatures</code>. Issue updates by calling <code>update()</code> and passing
functions that update the model. Verify that the nesting works.</li>
</ul>
<p>When you are ready, continue on to <a href="13-obj-func-update-react.html">13 - Object Function Update</a>.</p>
<p><a href="toc.html">Table of Contents</a></p>

</body></html>