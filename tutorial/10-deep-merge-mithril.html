<!DOCTYPE html><html>
<head>
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="stylesheet" href="normalize.css">
<link rel="stylesheet" href="skeleton.css">
<link rel="stylesheet" href="prism.css">
<link rel="stylesheet" href="style.css">
</head>
<body class="container">
<script src="https://flems.io/flems.html" type="text/javascript" charset="utf-8"></script>
<script src="prism.js" type="text/javascript"></script>
<h1>Meiosis Tutorial</h1><p><a href="toc.html">Table of Contents</a></p>
<h2>10 - Deep Merge</h2><p>In the previous lesson, <a href="09-nesting-mithril.html">09 - Nesting</a>, we looked at how we could
<strong>nest</strong> the <code>update</code> function so that we could have multiple instances of the temperature
element, each at its own path within the top-level model. The temperature code did not need
to change, it continued to work with just its own subset of the model.</p>
<p>As a first way of signaling nested updates, we used objects shaped as <code>{ path: ..., data: ... }</code>
to indicate the path at which to update the model. In this lesson, we&#39;ll use a different approach.</p>
<h3>Let&#39;s try going back to <code>Object.assign</code></h3><p>Instead of sending updates as <code>{ path: ..., data: ... }</code>, let&#39;s try going back to using
<code>Object.assign</code>. Remember, in that case we just sent data objects as updates, and merged them in
with <code>Object.assign</code>. At the time, we weren&#39;t nesting, so our top-level model was:</p>
<pre><code class="language-js">{ value: 22, units: &quot;C&quot; }
</code></pre>
<p>We were sending updates such a <code>{ value: 23 }</code>.</p>
<p>Now, our top-level model is:</p>
<pre><code class="language-js">{ air:   { value: 22, units: &quot;C&quot; },
  water: { value: 84, units: &quot;F&quot; }
}
</code></pre>
<p>So we need to send updates such as:</p>
<pre><code class="language-js">{ air: { value: 23 } }
</code></pre>
<p>We then hope to merge that in with the top-level model to obtain:</p>
<pre><code class="language-js">{ air:   { value: 22, units: &quot;C&quot; },
  water: { value: 84, units: &quot;F&quot; }
}
</code></pre>
<h3>Nesting with plain data objects</h3><p>Whereas before we were &quot;tagging&quot; our updates with a <code>path</code> property, nesting with plain data
objects is just a matter of placing the incoming data within the object using the path:</p>
<pre><code class="language-js">var nest = function(update, prop) {
  return function(obj) {
    var result = {};
    result[prop] = obj;
    update(result);
  };
};
</code></pre>
<p>Again we are wrapping <code>update</code> with <code>nest</code>. Now, when the temperature code calls
<code>update({ value: 23 })</code>, if we nest the temperature element with <code>nest(update, &quot;air&quot;)</code>, the
update will be transformed into <code>{ air: { value: 23 } }</code>.</p>
<p><img src="10-deep-merge-01.svg" alt="Nesting objects"></p>
<p>We can then try to merge in the update using <code>Object.assign</code> as our accumulator function:</p>
<pre><code class="language-js">var models = m.stream.scan(Object.assign,
  { air:   { value: 22, units: &quot;C&quot; },
    water: { value: 84, units: &quot;F&quot; }
  },
  update);
</code></pre>
<p>But this doesn&#39;t work. Try it out below. Can you see what is not quite working? Do you have an
idea why?</p>
  <div id="flems1" class="flemscode" style="height:800px"></div>

  <script>
    window.Flems(flems1, {
      files: [{name: "10-deep-merge-a.js", content: "/*global m*/\n\n// -- Utility code\n\nvar nest = function(update, prop) {\n  return function(obj) {\n    var result = {};\n    result[prop] = obj;\n    update(result);\n  };\n};\n\n// -- Application code\n\nvar convert = function(value, to) {\n  if (to === \"C\") {\n    return Math.round( (value - 32) / 9 * 5 );\n  }\n  else {\n    return Math.round( value * 9 / 5 + 32 );\n  }\n};\n\nvar createTemperature = function(update, label) {\n  var increase = function(model, amount) {\n    return function(_event) {\n      update({ value: model.value + amount });\n    };\n  };\n  var changeUnits = function(model) {\n    return function(_event) {\n      var newUnits = model.units === \"C\" ? \"F\" : \"C\";\n      var newValue = convert(model.value, newUnits);\n      update({ value: newValue, units: newUnits });\n    };\n  };\n\n  var view = function(model) {\n    return m(\"div.temperature\", [\n      label, \" Temperature: \", model.value, m.trust(\"&deg;\"), model.units,\n      m(\"div\",\n        m(\"button\", { onclick: increase(model, 1) }, \"Increase\"),\n        m(\"button\", { onclick: increase(model,-1) }, \"Decrease\")\n      ),\n      m(\"div\",\n        m(\"button\", { onclick: changeUnits(model) }, \"Change Units\")\n      )\n    ]);\n  };\n  return view;\n};\n\nvar createView = function(update) {\n  var air = createTemperature(nest(update, \"air\"), \"Air\");\n  var water = createTemperature(nest(update, \"water\"), \"Water\");\n\n  return function(model) {\n    return [\n      air(model.air),\n      water(model.water)\n    ];\n  };\n};\n\n// -- Meiosis pattern setup code\n\nvar update = m.stream();\nvar view = createView(update);\n\n// This doesn't work!\nvar models = m.stream.scan(Object.assign,\n  { air:   { value: 22, units: \"C\" },\n    water: { value: 84, units: \"F\" }\n  },\n  update);\n\nvar element = document.getElementById(\"app\");\n\nmodels.map(function(model) {\n  m.render(element, view(model));\n});\n"},{name: "app.html", content: "<div id=\"app\"></div>\n"},{name: "app.css", content: "body, button {\n  font-family: sans-serif;\n  font-size: 1rem;\n}\nbutton {\n  cursor: pointer;\n  padding: 2px 8px 2px 8px;\n  color: #5755d9;\n  background-color: #ffffff;\n  border: 1px solid #5755d9;\n  margin: 4px;\n}\nbutton:hover {\n  background-color: #eeeeee;\n}\n.temperature {\n  margin-bottom: 20px;\n}"}],
      links: [{name: "mithril", type: "js", url: "https://unpkg.com/mithril@1.1.6"},{name: "mithril-stream", type: "js", url: "https://unpkg.com/mithril-stream@1.1.0"}],
      middle: 75
    })
  </script>


<p>Above, changing units works at first, but increasing or decreasing the temperature causes us to
lose the units. What&#39;s happening?</p>
<h3>Deep Merge</h3><p>The problem is that <code>Object.assign</code> does a <strong>shallow</strong> merge: it only merges properties at the
first level. Nested properties from the source <strong>overwrite</strong> the nested properties in the target:</p>
<pre><code class="language-js">Object.assign(
  { air:   { value: 22, units: &quot;C&quot; },
    water: { value: 84, units: &quot;F&quot; }
  },
  { air:   { value: 23 }
  }
);
// Result is:
  { air:   { value: 23 },
    water: { value: 84, units: &quot;F&quot; }
  },
</code></pre>
<p>As you can see above, at the first level we have <code>air</code> and <code>water</code>, so <code>Object.assign</code> merges
<code>air</code> and keeps <code>water</code>. But after that, whatever is under <code>air</code> overwrites whatever was there
previously. So <code>{ value: 23 }</code> entirely replaces <code>{ value: 22, units: &quot;C&quot; }</code> and we lose <code>units</code>.</p>
<p>What we need is a <strong>deep</strong> merge, so that properties at every level are merged together.</p>
<p>There are several options for deep merge support. One of them is <a href="http://lodash.com">Lodash</a>,
which provides <a href="https://lodash.com/docs/4.17.5#merge">_.merge</a>. Another is
<a href="https://github.com/KyleAMathews/deepmerge">deepmerge</a>, which is a tiny library dedicated to
provide deep merge support.</p>
<p>Before we do that, though, let&#39;s talk about <strong>multiple</strong> levels of nesting.</p>
<h3>Multiple Levels of Nesting</h3><p>Now that we&#39;ll be passing plain objects via <code>update</code> and merging them into the model, we can use
more than one level of nesting.</p>
<p>What I mean by that is, we can nest temperatures at <code>air</code> and <code>water</code>, but then we can create
another element, <code>temperaturePair</code>, which contains the <code>air</code> and <code>water</code> temperatures. Then, we
can in turn nest <code>temperaturePair</code> at <code>temperatures</code>.</p>
<p>Our top-level model is now:</p>
<pre><code class="language-js">{ temperatures:
  { air:   { value: 22, units: &quot;C&quot; },
    water: { value: 84, units: &quot;F&quot; }
  }
}
</code></pre>
<p>The following illustrates multiple levels of nesting. <code>createTemperaturePair</code> nests
<code>createTemperature</code> at <code>air</code> and <code>water</code>. <code>createView</code> in turn nests <code>createTemperaturePair</code>  at
<code>temperatures</code>.</p>
<p><img src="10-deep-merge-02.svg" alt="Multiple nesting"></p>
<p>Multiple levels of nesting means that we can use and re-use elements at various points within our
top-level model. The code for these elements does not need to change, and is blissfully unaware of
where they are nested within the top-level model. They can happily continue to work with just their
model.</p>
<p>This also enables us to have elements that use properties like <code>value</code> in their model, without
conflicting with other elements that also use <code>value</code>. Each element has its separate place within
the top-level model. We can compose elements out of other elements, and compose <em>those</em> elements
into other elements, and so on.</p>
<p>Let&#39;s put everything together. You can see how we have multiple levels of nesting. As previously
discussed, we&#39;re using Lodash&#39;s <code>_.merge</code> to achieve deep merging of updates into the model.</p>
  <div id="flems2" class="flemscode" style="height:800px"></div>

  <script>
    window.Flems(flems2, {
      files: [{name: "10-deep-merge.js", content: "/*global m, _*/\n\n// -- Utility code\n\nvar nest = function(update, prop) {\n  return function(obj) {\n    var result = {};\n    result[prop] = obj;\n    update(result);\n  };\n};\n\n// -- Application code\n\nvar convert = function(value, to) {\n  if (to === \"C\") {\n    return Math.round( (value - 32) / 9 * 5 );\n  }\n  else {\n    return Math.round( value * 9 / 5 + 32 );\n  }\n};\n\nvar createTemperature = function(update, label) {\n  var increase = function(model, amount) {\n    return function(_event) {\n      update({ value: model.value + amount });\n    };\n  };\n  var changeUnits = function(model) {\n    return function(_event) {\n      var newUnits = model.units === \"C\" ? \"F\" : \"C\";\n      var newValue = convert(model.value, newUnits);\n      update({ value: newValue, units: newUnits });\n    };\n  };\n\n  var view = function(model) {\n    return m(\"div.temperature\", [\n      label, \" Temperature: \", model.value, m.trust(\"&deg;\"), model.units,\n      m(\"div\",\n        m(\"button\", { onclick: increase(model, 1) }, \"Increase\"),\n        m(\"button\", { onclick: increase(model,-1) }, \"Decrease\")\n      ),\n      m(\"div\",\n        m(\"button\", { onclick: changeUnits(model) }, \"Change Units\")\n      )\n    ]);\n  };\n  return view;\n};\n\nvar createTemperaturePair = function(update) {\n  var air = createTemperature(nest(update, \"air\"), \"Air\");\n  var water = createTemperature(nest(update, \"water\"), \"Water\");\n\n  return function(model) {\n    return [\n      air(model.air),\n      water(model.water)\n    ];\n  };\n};\n\nvar createView = function(update) {\n  var pair = createTemperaturePair(nest(update, \"temperatures\"));\n\n  return function(model) {\n    return pair(model.temperatures);\n  };\n};\n\n// -- Meiosis pattern setup code\n\nvar update = m.stream();\nvar view = createView(update);\n\nvar models = m.stream.scan(_.merge,\n  { temperatures:\n    { air:   { value: 22, units: \"C\" },\n      water: { value: 84, units: \"F\" }\n    }\n  },\n  update);\n\nvar element = document.getElementById(\"app\");\n\nmodels.map(function(model) {\n  m.render(element, view(model));\n});\n"},{name: "app.html", content: "<div id=\"app\"></div>\n"},{name: "app.css", content: "body, button {\n  font-family: sans-serif;\n  font-size: 1rem;\n}\nbutton {\n  cursor: pointer;\n  padding: 2px 8px 2px 8px;\n  color: #5755d9;\n  background-color: #ffffff;\n  border: 1px solid #5755d9;\n  margin: 4px;\n}\nbutton:hover {\n  background-color: #eeeeee;\n}\n.temperature {\n  margin-bottom: 20px;\n}"}],
      links: [{name: "mithril", type: "js", url: "https://unpkg.com/mithril@1.1.6"},{name: "mithril-stream", type: "js", url: "https://unpkg.com/mithril-stream@1.1.0"},{name: "lodash", type: "js", url: "https://unpkg.com/lodash@4.17.5"}],
      middle: 75
    })
  </script>


<h3>Exercise</h3><ul>
<li>Add another element next to <code>temperatures</code> so that your top-level model is
<code>{ temperatures: ..., other: ... }</code>, of course replacing <code>other</code> with your choice of property name.
The element that you add should not &quot;know&quot; where it is nested within the top-level model. For bonus
points, add another element that is nested within the element that you added.</li>
</ul>
<p>When you are ready, continue on to <a href="11-components-mithril.html">11 - Components</a>.</p>
<p><a href="toc.html">Table of Contents</a></p>

</body></html>