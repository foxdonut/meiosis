<!DOCTYPE html><html>
<head>
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="stylesheet" href="normalize.css">
<link rel="stylesheet" href="skeleton.css">
<link rel="stylesheet" href="prism.css">
<link rel="stylesheet" href="style.css">
</head>
<body class="container">
<script src="https://flems.io/flems.html" type="text/javascript" charset="utf-8"></script>
<script src="prism.js" type="text/javascript"></script>
<h1>Meiosis Tutorial</h1><p><a href="toc.html">Table of Contents</a></p>
<h2>09 - Nesting</h2><p>In the previous lesson, <a href="08-accumulator-mithril.html">08 - Accumulator</a>, we changed our strategy
for accumulating updates. We switched to sending objects on the update stream, and we changed our
accumulator function to use <code>Object.assign</code> to merge updates into the model. This enabled us to
use objects for our model rather than just numbers.</p>
<h3>A Single Top-Level Model</h3><p>Now, we just have the temperature in our example. Obviously, a larger application will have many
more elements in the view. We&#39;d like each element to have its own model, but we still want to
have a <strong>single top-level model</strong> and a root <code>view(model)</code> function. How can we accomplish this?</p>
<p>Let&#39;s take the example of having <em>two</em> temperature elements in our app: one for the air temperature
and one for the water temperature. We want two <em>instances</em> of our temperature element, each with
its own <code>{ value: ..., units: ... }</code> model, but we want a top-level model that differentiates one
from the other:</p>
<pre><code class="language-js">{ air:   { value: 22, units: &quot;C&quot; },
  water: { value: 84, units: &quot;F&quot; }
}
</code></pre>
<p>Having a single top-level model gives us a <strong>single source of truth</strong> and combined with a root
<code>view = function(model)</code>, we continue having a simple reactive loop with the Meiosis pattern:</p>
<p><img src="09-nesting-01.svg" alt="The Reactive Loop"></p>
<p>To reach our goal, we use a technique that I call <strong>nesting</strong>.</p>
<h3>Nesting Models</h3><p>Remember that we had a <code>createView</code> function which returned a <code>view</code> function. By calling
<code>view(model)</code>, we were able to render (and re-render) the temperature.</p>
<p>Our goal is to have <em>two</em> temperatures in the view, but we want to <strong>reuse the same code,</strong>
<strong>without changing it</strong>. So each temperature still deals with a model that looks like:</p>
<pre><code class="language-js">{ value: 22, units: &quot;C&quot; }
</code></pre>
<p>But we want to have a top-level model that looks like:</p>
<pre><code class="language-js">{ air:   { value: 22, units: &quot;C&quot; },
  water: { value: 84, units: &quot;F&quot; }
}
</code></pre>
<p>We&#39;ll rename the <code>createView</code> function to <code>createTemperature</code>, but it will work the same as
before. Our top-level <code>createView</code> function will create two instances of temperature:</p>
<pre><code class="language-js">var createView = function(update) {
  var air = createTemperature(update);
  var water = createTemperature(update);

  return function(model) {
    return [
      air(model.air),
      water(model.water)
    ];
  };
};
</code></pre>
<p>The idea is that <code>air</code> and <code>water</code> are the <code>view(model)</code> functions for temperature, and our
top-level <code>view</code> function calling <code>air(model.air)</code> and <code>water(model.water)</code> to render the two
temperature instances one after the other. Notice that we pass <code>model.air</code> and <code>model.water</code>
from the top-level model so that each instance has its &quot;sub-model&quot; of <code>{ value: ..., unit: ... }</code>
and continues to work as it did before, without needing to &quot;know&quot; about the top-level model:</p>
<p><img src="09-nesting-02.svg" alt="Nesting Models"></p>
<p>Just to make things a little more obvious, we&#39;ll add a <code>label</code> parameter to the <code>createTemperature</code>
function and render the label in the view:</p>
<pre><code class="language-js">var createTemperature = function(update, label) {
  // ...
  var view = function(model) {
    return m(&quot;div.temperature&quot;, [
      label, &quot; Temperature: &quot;, // ...
      // ...
    ]);
  };
  return view;
}

// ...
  var air = createTemperature(update, &quot;Air&quot;);
  var water = createTemperature(update, &quot;Water&quot;);
</code></pre>
<p>That way, we can clearly see the <code>Air</code> and <code>Water</code> temperature in the view. Below is the code that
we have so far. Note that updates don&#39;t work yet, so clicking on <code>Increase</code>, <code>Decrease</code>, and
<code>Change Units</code> won&#39;t have any effect.</p>
  <div id="flems1" class="flemscode" style="height:800px"></div>

  <script>
    window.Flems(flems1, {
      files: [{name: "09-nesting-a.js", content: "/*global m*/\n\n// -- Application code\n\nvar convert = function(value, to) {\n  if (to === \"C\") {\n    return Math.round( (value - 32) / 9 * 5 );\n  }\n  else {\n    return Math.round( value * 9 / 5 + 32 );\n  }\n};\n\nvar createTemperature = function(update, label) {\n  var increase = function(model, amount) {\n    return function(_event) {\n      update({ value: model.value + amount });\n    };\n  };\n  var changeUnits = function(model) {\n    return function(_event) {\n      var newUnits = model.units === \"C\" ? \"F\" : \"C\";\n      var newValue = convert(model.value, newUnits);\n      update({ value: newValue, units: newUnits });\n    };\n  };\n\n  var view = function(model) {\n    return m(\"div.temperature\", [\n      label, \" Temperature: \", model.value, m.trust(\"&deg;\"), model.units,\n      m(\"div\",\n        m(\"button\", { onclick: increase(model, 1) }, \"Increase\"),\n        m(\"button\", { onclick: increase(model,-1) }, \"Decrease\")\n      ),\n      m(\"div\",\n        m(\"button\", { onclick: changeUnits(model) }, \"Change Units\")\n      )\n    ]);\n  };\n  return view;\n};\n\nvar createView = function(update) {\n  var air = createTemperature(update, \"Air\");\n  var water = createTemperature(update, \"Water\");\n\n  return function(model) {\n    return [\n      air(model.air),\n      water(model.water)\n    ];\n  };\n};\n\n// -- Meiosis pattern setup code\n\nvar update = m.stream();\nvar view = createView(update);\n\nvar models = m.stream.scan(Object.assign,\n  { air:   { value: 22, units: \"C\" },\n    water: { value: 84, units: \"F\" }\n  },\n  update);\n\nvar element = document.getElementById(\"app\");\n\nmodels.map(function(model) {\n  m.render(element, view(model));\n});\n"},{name: "app.html", content: "<div id=\"app\"></div>\n"},{name: "app.css", content: "body, button {\n  font-family: sans-serif;\n  font-size: 1rem;\n}\nbutton, button.light {\n  cursor: pointer;\n  padding: 2px 8px 2px 8px;\n  color: #5755d9;\n  background-color: #ffffff;\n  border: 1px solid #5755d9;\n  margin: 4px;\n}\nbutton:hover {\n  background-color: #eeeeee;\n}\nbutton.dark {\n  background-color: #5755d9;\n  color: #ffffff;\n}\nbutton.dark:hover {\n  background-color: #7775f9;\n}\n.temperature {\n  margin-bottom: 20px;\n}"}],
      links: [{name: "mithril", type: "js", url: "https://unpkg.com/mithril@1.1.6"},{name: "mithril-stream", type: "js", url: "https://unpkg.com/mithril-stream@1.1.0"}],
      middle: 75
    })
  </script>


<p>You can see each temperature being rendered from the top-level model, without the temperature view
needing to know about the <code>air</code> and <code>water</code> - instead, it continues to use <code>model.value</code> and
<code>model.units</code> as before.</p>
<p>The problem now is, how do we get updates to work? Let&#39;s address that next.</p>
<h3>Nesting Updates</h3><p>The reason that updates don&#39;t work is that our temperatures are sending updates as:</p>
<pre><code class="language-js">update({ value: 85 });
</code></pre>
<p>But our top-level <code>scan</code> uses <code>Object.assign</code> to merge the update with the top-level model, so
we end up with:</p>
<pre><code class="language-js">{ air:   { value: 22, units: &quot;C&quot; },
  water: { value: 84, units: &quot;F&quot; },
  value: 85
}
</code></pre>
<p><strong>What we want instead</strong> is to <strong>nest</strong> the <code>air</code> and <code>water</code> updates at their respective properties:</p>
<p><img src="09-nesting-03.svg" alt="Nesting Updates"></p>
<p>We can achieve this by <strong>wrapping the update</strong> function so that when a temperature calls:</p>
<pre><code class="language-js">update({ value: 85 });
</code></pre>
<p>We <strong>intercept</strong> the incoming <code>{ value: 85 }</code> and change it so that instead, we have:</p>
<pre><code class="language-js">update({ path: &quot;water&quot;, data: { value: 85 } });
</code></pre>
<p>Then, our accumulator function can use <code>path</code> and <code>data</code> to update the top-level model accordingly:</p>
<pre><code class="language-js">var models = m.stream.scan(
  function(model, obj) {
    model[obj.path] = Object.assign(model[obj.path], obj.data);
    return model;
  },
  { air:   { value: 22, units: &quot;C&quot; },
    water: { value: 84, units: &quot;F&quot; }
  },
  update);
</code></pre>
<p>Notice how we&#39;ve moved up the call to <code>Object.assign</code> so that it operates on the <code>obj.path</code>. Then
we set the result back to <code>model[obj.path]</code>, effectively &quot;nesting&quot; the update within the top-level
model.</p>
<h3>Wrapping the <code>update</code> function</h3><p>As stated earlier, the goal here is not to have to change the temperature code. So the temperature
does not need to &quot;know&quot; that its updates are associated to the <code>air</code> or <code>water</code> path. It continues
to call <code>update({ value: 23 })</code> or <code>update({ value: 82, units: &quot;F&quot; })</code> as it did before.</p>
<p>We can do this by <strong>wrapping</strong> the <code>update</code> function so that we convert updates from plain data
into the form of <code>{ path: ..., data: ... }</code> before calling the &quot;real&quot; <code>update</code> function:</p>
<pre><code class="language-js">var nest = function(update, path) {
  return function(data) {
    update({ path: path, data: data });
  };
};
</code></pre>
<p>What we&#39;re doing here is creating a new function that will be a &quot;stand-in&quot; for the <code>update</code>
function that we pass to the temperature code. When the temperature code calls <code>update(...)</code>,
it will effectively be calling the inner <code>function(data)</code>, which turns around and calls
<code>update</code> with the converted object with <code>path</code> and <code>data</code>.</p>
<p><img src="09-nesting-04.svg" alt="Wrapping Update"></p>
<p>Now, to use the <code>nest</code> function, all we have to do is change this code:</p>
<pre><code class="language-js">var air = createTemperature(update, &quot;Air&quot;);
var water = createTemperature(update, &quot;Water&quot;);
</code></pre>
<p>To this code:</p>
<pre><code class="language-js">var air = createTemperature(nest(update, &quot;air&quot;), &quot;Air&quot;);
var water = createTemperature(nest(update, &quot;water&quot;), &quot;Water&quot;);
</code></pre>
<p>There you have it, instead of passing <code>update</code> directly, we use <code>nest</code> to wrap <code>update</code> with the
path that we specify, <code>air</code> and <code>water</code>. The temperature code does not need to change, and the
updates now work correctly, as you can see in the complete example below.</p>
  <div id="flems2" class="flemscode" style="height:800px"></div>

  <script>
    window.Flems(flems2, {
      files: [{name: "09-nesting.js", content: "/*global m*/\n\n// -- Utility code\n\nvar nest = function(update, path) {\n  return function(data) {\n    update({ path: path, data: data });\n  };\n};\n\n// -- Application code\n\nvar convert = function(value, to) {\n  if (to === \"C\") {\n    return Math.round( (value - 32) / 9 * 5 );\n  }\n  else {\n    return Math.round( value * 9 / 5 + 32 );\n  }\n};\n\nvar createTemperature = function(update, label) {\n  var increase = function(model, amount) {\n    return function(_event) {\n      update({ value: model.value + amount });\n    };\n  };\n  var changeUnits = function(model) {\n    return function(_event) {\n      var newUnits = model.units === \"C\" ? \"F\" : \"C\";\n      var newValue = convert(model.value, newUnits);\n      update({ value: newValue, units: newUnits });\n    };\n  };\n\n  var view = function(model) {\n    return m(\"div.temperature\", [\n      label, \" Temperature: \", model.value, m.trust(\"&deg;\"), model.units,\n      m(\"div\",\n        m(\"button\", { onclick: increase(model, 1) }, \"Increase\"),\n        m(\"button\", { onclick: increase(model,-1) }, \"Decrease\")\n      ),\n      m(\"div\",\n        m(\"button\", { onclick: changeUnits(model) }, \"Change Units\")\n      )\n    ]);\n  };\n  return view;\n};\n\nvar createView = function(update) {\n  var air = createTemperature(nest(update, \"air\"), \"Air\");\n  var water = createTemperature(nest(update, \"water\"), \"Water\");\n\n  return function(model) {\n    return [\n      air(model.air),\n      water(model.water)\n    ];\n  };\n};\n\n// -- Meiosis pattern setup code\n\nvar update = m.stream();\nvar view = createView(update);\n\nvar models = m.stream.scan(\n  function(model, obj) {\n    model[obj.path] = Object.assign(model[obj.path], obj.data);\n    return model;\n  },\n  { air:   { value: 22, units: \"C\" },\n    water: { value: 84, units: \"F\" }\n  },\n  update);\n\nvar element = document.getElementById(\"app\");\n\nmodels.map(function(model) {\n  m.render(element, view(model));\n});\n"},{name: "app.html", content: "<div id=\"app\"></div>\n"},{name: "app.css", content: "body, button {\n  font-family: sans-serif;\n  font-size: 1rem;\n}\nbutton, button.light {\n  cursor: pointer;\n  padding: 2px 8px 2px 8px;\n  color: #5755d9;\n  background-color: #ffffff;\n  border: 1px solid #5755d9;\n  margin: 4px;\n}\nbutton:hover {\n  background-color: #eeeeee;\n}\nbutton.dark {\n  background-color: #5755d9;\n  color: #ffffff;\n}\nbutton.dark:hover {\n  background-color: #7775f9;\n}\n.temperature {\n  margin-bottom: 20px;\n}"}],
      links: [{name: "mithril", type: "js", url: "https://unpkg.com/mithril@1.1.6"},{name: "mithril-stream", type: "js", url: "https://unpkg.com/mithril-stream@1.1.0"}],
      middle: 75
    })
  </script>


<h3>Exercise</h3><ul>
<li>Try adding another temperature with the label and the model property of your choice. Make sure
that it works by trying it out in the application. Which code did you need to add or change? Which
code did not need any changes?</li>
</ul>
<p>When you are ready, continue on to <a href="10-deep-merge-mithril.html">10 - Deep Merge</a>.</p>
<p><a href="toc.html">Table of Contents</a></p>
<hr>
<p>Meiosis is developed by <a href="http://twitter.com/foxdonut00">@foxdonut00</a> / <a href="https://github.com/foxdonut">foxdonut</a> and is released under the MIT license.</p>

</body></html>