<!DOCTYPE html>
<html>
  <head>
    <title>Meiosis Documentation</title>
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="stylesheet" href="normalize.css">
    <link rel="stylesheet" href="skeleton.css">
    <link rel="stylesheet" href="prism.css">
    <link rel="stylesheet" href="style.css">
  </head>
  <body class="container">
    <script src="prism.js" type="text/javascript"></script>
    <script src="flems.html" type="text/javascript" charset="utf-8"></script>
    <h1><a href="https://meiosis.js.org">Meiosis</a> Documentation</h1><p><a href="toc.html">Table of Contents</a></p>
<h2>Services</h2><p><a href="https://james-forbes.com">James Forbes</a> shared his idea of <em>Services</em>. In this section, we&#39;ll look
at James&#39; version using streams, and another version using
<a href="https://github.com/foxdonut/meiosis/tree/master/helpers/setup#meiosis-setup">meiosis-setup</a>
with <a href="https://github.com/fuzetsu">Daniel Loomer</a>&#39;s
<a href="https://github.com/fuzetsu/mergerino">Mergerino</a>.</p>
<p>James explains that while one-off actions occur after click events, user input, and so on,
services are for ongoing state synchronization. They can produce computed properties, store and
retrieve state from local storage, and trigger other actions.</p>
<p><a name="using_streams"></a></p>
<h3><a href="#using_streams">Using Streams</a></h3><p>James&#39; version uses streams to implement services. The structure is as follows:</p>
<pre><code class="language-javascript">{
  initial: state =&gt; initialState,
  start: states =&gt; patches
}</code></pre>
<p>A service has an <code>initial</code> function which produces the service&#39;s initial state. The <code>start</code>
function takes the Meiosis <strong>stream</strong> of states and returns a <strong>stream</strong> of patches. The
service emits patches onto this stream.</p>
<p>The application&#39;s initial state is combined with each service&#39;s initial state to produce the
final initial state:</p>
<pre><code class="language-javascript">const services = [ /* ... */ ];

const initialState = () =&gt; {
  const state = {
    boxes: [],
    colors: [&quot;red&quot;, &quot;purple&quot;, &quot;blue&quot;]
  };
  return Object.assign(
    {},
    state,
    services.map(s =&gt; s.initial(state)).reduce(R.merge, {})
  );
};</code></pre>
<p>Then, every service is started by passing in the stream of states, and mapping the resulting stream
of patches onto the <code>update</code> stream:</p>
<pre><code class="language-javascript">services.map(s =&gt; s.start(states).map(update));</code></pre>
<p>When a service emits a patch onto its stream, it is passed on to the <code>update</code> stream.</p>
<h4>Colored Boxes Example</h4><p>James shared an example where you have colored boxes that you can click on to add them to a list.
The boxes are displayed one next to the other, with a description of how many boxes of each color
are in the list. You can remove a box from the list by clicking on it.</p>
<blockquote>
<p>Note that the example code is somewhat different that the &quot;Meiosis style&quot;. There are some nifty
functional programming at play here, and you can learn some nice techniques from this code. But if
you are having some trouble understanding, please know that the code in the next section uses a
style that is closer to what we have been using so far.</p>
</blockquote>
<p>In the example, there are three services:</p>
<ul>
<li><code>StatsService</code>: produces an object that indicates how many boxes of each color.</li>
<li><code>LocalStorageService</code>: stores and retrieves the box data to and from local storage. You will
notice that the box list remains even after reloading the page.</li>
<li><code>DescriptionService</code>: produces the text description of how many boxes of each color are in
the list.</li>
</ul>
<p>Each service has an <code>initial</code> and <code>start</code> function. For example, the <code>StatsService</code> initializes its
state with <code>0</code> for every box color, and computes the number of instances of each color:</p>
<pre><code class="language-javascript">const StatsService = {
  initial(state) {
    return state.colors
      .map(R.objOf)
      .map(K(0))
      .reduce(R.merge, {});
  },
  start(state) {
    return dropRepeats(state.map(x =&gt; x.boxes))
      .map(R.countBy(I))
      .map(R.assoc(&quot;stats&quot;));
  }
};</code></pre>
<p>Notice the call to <code>dropRepeats</code>. This is necessary because the stream of patches produced by the
service is fed back into the Meiosis <code>update</code> stream. This in turn produces an updated state, which
triggers the service again. To avoid an infinite loop, <code>dropRepeats</code> does not emit a value when it
is the same as the previous one:</p>
<pre><code class="language-javascript">function dropRepeats(s) {
  var ready = false;
  var d = m.stream();
  s.map(function (v) {
    if (!ready || v !== d()) {
      ready = true;
      d(v);
    }
  });
  return d;
}</code></pre>
<p>The example uses function patches. Here is the setup for the Meiosis pattern:</p>
<pre><code class="language-javascript">const update = m.stream();
const T = (x, f) =&gt; f(x);
const state = m.stream.scan(T, initialState(), update);
const element = document.getElementById(&quot;app&quot;);
states.map(view(update)).map(v =&gt; m.render(element, v));</code></pre>
<p>The complete example is below.</p>
  <div id="flems1" class="flemscode" style="height:700px"></div>

  <script>
    window.Flems(flems1, {
      files: [{name: "index-streams.js", content: "/* global b, m, R */\n\nconst I = x => x;\nconst o = (f, g) => x => f(g(x));\nconst K = x => () => x;\n\nfunction dropRepeats(s) {\n  var ready = false;\n  var d = m.stream();\n  s.map(function(v) {\n    if (!ready || v !== d()) {\n      ready = true;\n      d(v);\n    }\n  });\n  return d;\n}\n\nconst humanList = s => xs =>\n  xs.length > 1\n    ? xs.slice(0, -1).join(\", \") +\n      \" \" +\n      s +\n      \" \" +\n      xs.slice(-1)\n    : xs.join(\"\");\n\nconst pipe = xs => xs.reduceRight(o, I);\nconst $ = {\n  prop: k => f => o => Object.assign(o, { [k]: f(o[k]) }),\n  get: lens => o => {\n    var y;\n    lens(x => (y = x))(o);\n    return y;\n  }\n};\n\nconst $boxes = $.prop(\"boxes\");\nconst $description = $.prop(\"description\");\nconst $colors = $.prop(\"colors\");\n\nconst Action = {\n  addBox: x =>\n    pipe([K(x), x => xs => xs.concat(x), $boxes]),\n  removeBox: i => $boxes(xs => xs.filter((x, j) => i != j))\n};\n\nconst view = update => state =>\n  m(\n    \".app\" + b.d(\"grid\").ff(\"Helvetica\"),\n    m(\n      \"nav.header\" +\n        b\n          .d(\"flex\")\n          .jc(\"space-between\")\n          .ai(\"center\")\n          .bc(\"steelblue\")\n          .c(\"white\")\n          .p(\"1em\"),\n\n      m(\"h1\" + b.m(0), \"Boxes\"),\n      $.get($colors)(state).map(x =>\n        m(\n          \"button\" +\n            b\n              .bc(x)\n              .c(\"white\")\n              .w(\"2em\")\n              .h(\"2em\")\n              .fs(\"2em\")\n              .m(0)\n              .border(\"none\"),\n          { onclick: pipe([Action.addBox(x), update]) },\n          \"+\"\n        )\n      )\n    ),\n    m(\"p\", $.get($description)(state)),\n    m(\n      \"\" +\n        b\n          .d(\"grid\")\n          .gridTemplateColumns(\"repeat(3, 1fr)\")\n          .alignItems(\"center\")\n          .justifyItems(\"center\")\n          .padding(\"1em\")\n          .gridRowGap(\"1em\")\n          .maxHeight(\"14em\")\n          .overflowY(\"auto\"),\n\n      $.get($boxes)(state).map((x, i) =>\n        m(\n          \"\" +\n            b\n              .bc(x)\n              .c(\"white\")\n              .w(\"4em\")\n              .h(\"4em\"),\n          {\n            onclick: pipe([K(Action.removeBox(i)), update])\n          }\n        )\n      )\n    )\n  );\n\nconst StatsService = {\n  initial(state) {\n    return state.colors\n      .map(R.objOf)\n      .map(K(0))\n      .reduce(R.merge, {});\n  },\n  start(state) {\n    return dropRepeats(state.map(x => x.boxes))\n      .map(R.countBy(I))\n      .map(R.assoc(\"stats\"));\n  }\n};\n\nconst LocalStorageService = {\n  initial() {\n    return [localStorage.getItem(\"v1\")]\n      .filter(Boolean)\n      .map(JSON.parse)\n      .concat({ boxes: [] })\n      .shift();\n  },\n  start(state) {\n    const update = m.stream();\n\n    dropRepeats(state.map(R.pick([\"boxes\"]))).map(x =>\n      localStorage.setItem(\"v1\", JSON.stringify(x))\n    );\n\n    return update;\n  }\n};\n\nconst DescriptionService = {\n  initial() {\n    return {\n      description: \"\"\n    };\n  },\n  start(state) {\n    return dropRepeats(state.map(x => x.stats)).map(\n      R.pipe(\n        R.toPairs,\n        R.groupBy(R.last),\n        R.map(R.map(R.head)),\n        R.map(humanList(\"and\")),\n        R.toPairs,\n        R.map(R.join(\" \")),\n        humanList(\"and\"),\n        x => x + \".\",\n        R.objOf(\"description\"),\n        R.mergeDeepLeft\n      )\n    );\n  }\n};\n\nconst services = [\n  LocalStorageService,\n  StatsService,\n  DescriptionService\n];\n\nconst initialState = () => {\n  const state = {\n    boxes: [],\n    colors: [\"red\", \"purple\", \"blue\"]\n  };\n  return Object.assign(\n    {},\n    state,\n    services.map(s => s.initial(state)).reduce(R.merge, {})\n  );\n};\n\nconst update = m.stream();\nconst T = (x, f) => f(x);\nconst states = m.stream.scan(T, initialState(), update);\nconst element = document.getElementById(\"app\");\nstates.map(view(update)).map(v => m.render(element, v));\n\nservices.map(s => s.start(states).map(update));\n", compiler: "babel"},{name: "app.html", content: "<div id=\"app\"></div>\n<div id=\"tracer\"></div>\n"}],
      links: [{name: "mithril", type: "js", url: "https://unpkg.com/mithril@2.0.4"},{name: "mithril-stream", type: "js", url: "https://unpkg.com/mithril@2.0.4/stream/stream.js"},{name: "ramda", type: "js", url: "https://unpkg.com/ramda@0.25.0/dist/ramda.min.js"},{name: "bss", type: "js", url: "https://unpkg.com/bss@1.3.0/bss.js"}],
      middle: 60,

      autoFocus: false
    })
  </script>


<h4>Flexibility</h4><p>Using streams gives you the flexibility of being able to hook into them and wiring them as you
wish.</p>
<p><a name="conclusion"></a></p>
<h3><a href="#conclusion">Conclusion</a></h3><p>We can use services for computed properties, state synchronization, and other purposes. Please note,
however, that not everything belongs in a service, so it&#39;s important to avoid getting carried away.</p>
<p>In <a href="services-and-effects.html">this section</a>, we look at how services and effects work in Meiosis.</p>
<hr>
<p><a href="toc.html">Table of Contents</a></p>
<hr>
<p><a href="https://meiosis.js.org">Meiosis</a> is developed by
<a href="http://twitter.com/foxdonut00">@foxdonut00</a> /
<a href="https://github.com/foxdonut">foxdonut</a>
and is released under the MIT license.</p>
  </body>
</html>
